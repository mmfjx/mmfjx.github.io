在 ES6 没有出现之前，随着 js 代码日益膨胀，往往会对资源模块化来提效，这也就出现了多个模块化方案。如 CommonJS 常用于服务端，AMD、CMD 规范常用在客户端。ES6 出现后，紧接着出现了 ESM。ESM 是浏览器支持的一种模块化方案，允许在浏览器实现模块化。

-   ESM:（ECMAScript Modules）是 ECMAScript 标准中定义的一种模块化方案，用于在浏览器和 Node.js 环境中实现模块化。

ESM 的特点和用法如下：

1. 静态导入和导出：ESM 的对外接口只是一种静态定义，为编译时加载。在模块中使用 import 关键字来导入其他模块的内容，使用 export 关键字来导出模块的内容。
2. 单独文件：每个 ESM 模块都是一个单独的文件，每个文件都是一个独立的模块。
3. 依赖关系：ESM 编译时就能确定模块的依赖关系，因此可以进行静态分析和优化。
4. 动态加载：ESM 支持动态加载模块，可以使用 import() 函数来动态加载模块。
5. 默认导出：一个模块可以有一个默认导出，通过 export default 语法来定义，默认导出的内容可以在导入时使用任意名称。
6. 命名导出：一个模块可以有多个命名导出，通过 export 语法来定义，导入时需要使用相应的名称。

在浏览器环境中，可以使用 <script type="module"> 标签来加载和执行 ESM 模块。在 Node.js 环境中，可以使用 .mjs 扩展名来表示 ESM 模块。

```javascript
// 导出一个变量
export const name = 'John'

// 导出一个函数
export function sayHello() {
    console.log('Hello!')
}

// 导出一个对象
export const person = {
    name: 'Alice',
    age: 25,
}
// 导入模块
import { name, sayHello, person } from './myModule'

console.log(name) // 输出: John

sayHello() // 输出: Hello!

console.log(person.name) // 输出: Alice
console.log(person.age) // 输出: 25
```

-   CommonJS：模块同步，如 Browserify 会对代码进行解析，整理出代码中的所有模块依赖关系，然后把 nodejs 的模块编译成浏览器可用的模块，相关的模块代码都打包在一起，形成一个完整的 JS 文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通 JS，运行时加载

```javascript
// 导出一个变量
exports.name = 'John'  //等价于 module.exports.name = 'John';

// 导出一个函数
exports.sayHello = function () {
    console.log('Hello!')
}

// 导出一个对象
exports.person = {
    name: 'Alice',
    age: 25,
}

// 总结起来，module.exports 是默认导出对象，而 exports 是对 module.exports 的引用。通过给它们的属性赋值，可以导出模块的内容。但是当需要导出一个新的对象或类时，应该直接使用 module.exports 赋值一个新的对象或类。

module.exports = {}
————————————————————————————————————————————————————
// 使用示例
// 导入模块
const myModule = require('./myModule')

// 使用导入的变量
console.log(myModule.name) // 输出: John

// 调用导入的函数
myModule.sayHello() // 输出: Hello!

// 使用导入的对象
console.log(myModule.person.name) // 输出: Alice
console.log(myModule.person.age) // 输出: 25
```

-   AMD：（Asynchronous Module Definition）模块异步，依赖前置，是 requireJS 在推广过程中对模块定义的规范化产出，用于在浏览器环境中异步加载模块。它的主要特点是依赖前置，即在定义模块时就声明其依赖的模块，并在加载完依赖后立即执行模块。

```javascript
// 定义一个模块
define(['dependency1', 'dependency2'], function (dep1, dep2) {
    // 模块的代码
    var module = {
        name: 'John',
        sayHello: function () {
            console.log('Hello, ' + dep1 + ' and ' + dep2 + '!')
        },
    }

    // 返回模块对象
    return module
})

// 使用模块
require(['myModule'], function (myModule) {
    myModule.sayHello() // 输出: Hello, dependency1 and dependency2!
})
```

-   CMD：（Common Module Definition）模块异步，用于在浏览器环境中异步加载模块。延迟执行，是 seaJS 在推广过程中对模块定义的规范化产出，就近依赖，先加载所有依赖模块，运行时才执行 require 内容，按顺序执行

```javascript
// 定义一个模块
define(function (require, exports, module) {
    // 引入依赖模块
    var dep1 = require('dependency1')
    var dep2 = require('dependency2')

    // 模块的代码
    var module = {
        name: 'John',
        sayHello: function () {
            console.log('Hello, ' + dep1 + ' and ' + dep2 + '!')
        },
    }

    // 导出模块对象
    module.exports = module
})

// 使用模块
require(['myModule'], function (myModule) {
    myModule.sayHello() // 输出: Hello, dependency1 and dependency2!
})
```

与 CommonJS、AMD 不同，ESM 的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令 import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。由于 ESM 编译时就能确定模块的依赖关系，因此能够只包含要运行的代码，可以显著减少文件体积，降低浏览器压力。
